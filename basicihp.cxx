// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "basicihp.hxx"

// Library
//

const Library::Component_type& Library::
Component () const
{
  return this->Component_.get ();
}

Library::Component_type& Library::
Component ()
{
  return this->Component_.get ();
}

void Library::
Component (const Component_type& x)
{
  this->Component_.set (x);
}

void Library::
Component (::std::unique_ptr< Component_type > x)
{
  this->Component_.set (std::move (x));
}

const Library::name_type& Library::
name () const
{
  return this->name_.get ();
}

Library::name_type& Library::
name ()
{
  return this->name_.get ();
}

void Library::
name (const name_type& x)
{
  this->name_.set (x);
}

void Library::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// Component
//

const Component::Description_type& Component::
Description () const
{
  return this->Description_.get ();
}

Component::Description_type& Component::
Description ()
{
  return this->Description_.get ();
}

void Component::
Description (const Description_type& x)
{
  this->Description_.set (x);
}

void Component::
Description (::std::unique_ptr< Description_type > x)
{
  this->Description_.set (std::move (x));
}

const Component::Netlists_type& Component::
Netlists () const
{
  return this->Netlists_.get ();
}

Component::Netlists_type& Component::
Netlists ()
{
  return this->Netlists_.get ();
}

void Component::
Netlists (const Netlists_type& x)
{
  this->Netlists_.set (x);
}

void Component::
Netlists (::std::unique_ptr< Netlists_type > x)
{
  this->Netlists_.set (std::move (x));
}

const Component::Symbols_type& Component::
Symbols () const
{
  return this->Symbols_.get ();
}

Component::Symbols_type& Component::
Symbols ()
{
  return this->Symbols_.get ();
}

void Component::
Symbols (const Symbols_type& x)
{
  this->Symbols_.set (x);
}

void Component::
Symbols (::std::unique_ptr< Symbols_type > x)
{
  this->Symbols_.set (std::move (x));
}

const Component::Parameters_type& Component::
Parameters () const
{
  return this->Parameters_.get ();
}

Component::Parameters_type& Component::
Parameters ()
{
  return this->Parameters_.get ();
}

void Component::
Parameters (const Parameters_type& x)
{
  this->Parameters_.set (x);
}

void Component::
Parameters (::std::unique_ptr< Parameters_type > x)
{
  this->Parameters_.set (std::move (x));
}

const Component::name_type& Component::
name () const
{
  return this->name_.get ();
}

Component::name_type& Component::
name ()
{
  return this->name_.get ();
}

void Component::
name (const name_type& x)
{
  this->name_.set (x);
}

void Component::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Component::schematic_id_type& Component::
schematic_id () const
{
  return this->schematic_id_.get ();
}

Component::schematic_id_type& Component::
schematic_id ()
{
  return this->schematic_id_.get ();
}

void Component::
schematic_id (const schematic_id_type& x)
{
  this->schematic_id_.set (x);
}

void Component::
schematic_id (::std::unique_ptr< schematic_id_type > x)
{
  this->schematic_id_.set (std::move (x));
}

const Component::show_name_type& Component::
show_name () const
{
  return this->show_name_.get ();
}

Component::show_name_type& Component::
show_name ()
{
  return this->show_name_.get ();
}

void Component::
show_name (const show_name_type& x)
{
  this->show_name_.set (x);
}


// Netlists
//

const Netlists::NgspiceNetlist_type& Netlists::
NgspiceNetlist () const
{
  return this->NgspiceNetlist_.get ();
}

Netlists::NgspiceNetlist_type& Netlists::
NgspiceNetlist ()
{
  return this->NgspiceNetlist_.get ();
}

void Netlists::
NgspiceNetlist (const NgspiceNetlist_type& x)
{
  this->NgspiceNetlist_.set (x);
}

void Netlists::
NgspiceNetlist (::std::unique_ptr< NgspiceNetlist_type > x)
{
  this->NgspiceNetlist_.set (std::move (x));
}


// Symbols
//

const Symbols::Symbol_type& Symbols::
Symbol () const
{
  return this->Symbol_.get ();
}

Symbols::Symbol_type& Symbols::
Symbol ()
{
  return this->Symbol_.get ();
}

void Symbols::
Symbol (const Symbol_type& x)
{
  this->Symbol_.set (x);
}

void Symbols::
Symbol (::std::unique_ptr< Symbol_type > x)
{
  this->Symbol_.set (std::move (x));
}


// Parameters
//

const Parameters::Parameter_sequence& Parameters::
Parameter () const
{
  return this->Parameter_;
}

Parameters::Parameter_sequence& Parameters::
Parameter ()
{
  return this->Parameter_;
}

void Parameters::
Parameter (const Parameter_sequence& s)
{
  this->Parameter_ = s;
}


// NgspiceNetlist
//

const NgspiceNetlist::value_type& NgspiceNetlist::
value () const
{
  return this->value_.get ();
}

NgspiceNetlist::value_type& NgspiceNetlist::
value ()
{
  return this->value_.get ();
}

void NgspiceNetlist::
value (const value_type& x)
{
  this->value_.set (x);
}

void NgspiceNetlist::
value (::std::unique_ptr< value_type > x)
{
  this->value_.set (std::move (x));
}


// Symbol
//

const Symbol::File_type& Symbol::
File () const
{
  return this->File_.get ();
}

Symbol::File_type& Symbol::
File ()
{
  return this->File_.get ();
}

void Symbol::
File (const File_type& x)
{
  this->File_.set (x);
}

void Symbol::
File (::std::unique_ptr< File_type > x)
{
  this->File_.set (std::move (x));
}

const Symbol::id_type& Symbol::
id () const
{
  return this->id_.get ();
}

Symbol::id_type& Symbol::
id ()
{
  return this->id_.get ();
}

void Symbol::
id (const id_type& x)
{
  this->id_.set (x);
}

void Symbol::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const Symbol::type_type& Symbol::
type () const
{
  return this->type_.get ();
}

Symbol::type_type& Symbol::
type ()
{
  return this->type_.get ();
}

void Symbol::
type (const type_type& x)
{
  this->type_.set (x);
}

void Symbol::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// Parameter
//

const Parameter::Description_type& Parameter::
Description () const
{
  return this->Description_.get ();
}

Parameter::Description_type& Parameter::
Description ()
{
  return this->Description_.get ();
}

void Parameter::
Description (const Description_type& x)
{
  this->Description_.set (x);
}

void Parameter::
Description (::std::unique_ptr< Description_type > x)
{
  this->Description_.set (std::move (x));
}

const Parameter::name_type& Parameter::
name () const
{
  return this->name_.get ();
}

Parameter::name_type& Parameter::
name ()
{
  return this->name_.get ();
}

void Parameter::
name (const name_type& x)
{
  this->name_.set (x);
}

void Parameter::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Parameter::unit_type& Parameter::
unit () const
{
  return this->unit_.get ();
}

Parameter::unit_type& Parameter::
unit ()
{
  return this->unit_.get ();
}

void Parameter::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void Parameter::
unit (::std::unique_ptr< unit_type > x)
{
  this->unit_.set (std::move (x));
}

const Parameter::default_value_type& Parameter::
default_value () const
{
  return this->default_value_.get ();
}

Parameter::default_value_type& Parameter::
default_value ()
{
  return this->default_value_.get ();
}

void Parameter::
default_value (const default_value_type& x)
{
  this->default_value_.set (x);
}

const Parameter::show_type& Parameter::
show () const
{
  return this->show_.get ();
}

Parameter::show_type& Parameter::
show ()
{
  return this->show_.get ();
}

void Parameter::
show (const show_type& x)
{
  this->show_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Library
//

Library::
Library (const Component_type& Component,
         const name_type& name)
: ::xml_schema::type (),
  Component_ (Component, this),
  name_ (name, this)
{
}

Library::
Library (::std::unique_ptr< Component_type > Component,
         const name_type& name)
: ::xml_schema::type (),
  Component_ (std::move (Component), this),
  name_ (name, this)
{
}

Library::
Library (const Library& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Component_ (x.Component_, f, this),
  name_ (x.name_, f, this)
{
}

Library::
Library (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Component_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Library::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Component
    //
    if (n.name () == "Component" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Component_type > r (
        Component_traits::create (i, f, this));

      if (!Component_.present ())
      {
        this->Component_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Component_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Component",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Library* Library::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Library (*this, f, c);
}

Library& Library::
operator= (const Library& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Component_ = x.Component_;
    this->name_ = x.name_;
  }

  return *this;
}

Library::
~Library ()
{
}

// Component
//

Component::
Component (const Description_type& Description,
           const Netlists_type& Netlists,
           const Symbols_type& Symbols,
           const Parameters_type& Parameters,
           const name_type& name,
           const schematic_id_type& schematic_id,
           const show_name_type& show_name)
: ::xml_schema::type (),
  Description_ (Description, this),
  Netlists_ (Netlists, this),
  Symbols_ (Symbols, this),
  Parameters_ (Parameters, this),
  name_ (name, this),
  schematic_id_ (schematic_id, this),
  show_name_ (show_name, this)
{
}

Component::
Component (const Description_type& Description,
           ::std::unique_ptr< Netlists_type > Netlists,
           ::std::unique_ptr< Symbols_type > Symbols,
           ::std::unique_ptr< Parameters_type > Parameters,
           const name_type& name,
           const schematic_id_type& schematic_id,
           const show_name_type& show_name)
: ::xml_schema::type (),
  Description_ (Description, this),
  Netlists_ (std::move (Netlists), this),
  Symbols_ (std::move (Symbols), this),
  Parameters_ (std::move (Parameters), this),
  name_ (name, this),
  schematic_id_ (schematic_id, this),
  show_name_ (show_name, this)
{
}

Component::
Component (const Component& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Description_ (x.Description_, f, this),
  Netlists_ (x.Netlists_, f, this),
  Symbols_ (x.Symbols_, f, this),
  Parameters_ (x.Parameters_, f, this),
  name_ (x.name_, f, this),
  schematic_id_ (x.schematic_id_, f, this),
  show_name_ (x.show_name_, f, this)
{
}

Component::
Component (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Description_ (this),
  Netlists_ (this),
  Symbols_ (this),
  Parameters_ (this),
  name_ (this),
  schematic_id_ (this),
  show_name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Component::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Description
    //
    if (n.name () == "Description" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Description_type > r (
        Description_traits::create (i, f, this));

      if (!Description_.present ())
      {
        this->Description_.set (::std::move (r));
        continue;
      }
    }

    // Netlists
    //
    if (n.name () == "Netlists" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Netlists_type > r (
        Netlists_traits::create (i, f, this));

      if (!Netlists_.present ())
      {
        this->Netlists_.set (::std::move (r));
        continue;
      }
    }

    // Symbols
    //
    if (n.name () == "Symbols" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Symbols_type > r (
        Symbols_traits::create (i, f, this));

      if (!Symbols_.present ())
      {
        this->Symbols_.set (::std::move (r));
        continue;
      }
    }

    // Parameters
    //
    if (n.name () == "Parameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Parameters_type > r (
        Parameters_traits::create (i, f, this));

      if (!Parameters_.present ())
      {
        this->Parameters_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Description_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Description",
      "");
  }

  if (!Netlists_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Netlists",
      "");
  }

  if (!Symbols_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Symbols",
      "");
  }

  if (!Parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Parameters",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "schematic_id" && n.namespace_ ().empty ())
    {
      this->schematic_id_.set (schematic_id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "show_name" && n.namespace_ ().empty ())
    {
      this->show_name_.set (show_name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!schematic_id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "schematic_id",
      "");
  }

  if (!show_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "show_name",
      "");
  }
}

Component* Component::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Component (*this, f, c);
}

Component& Component::
operator= (const Component& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Description_ = x.Description_;
    this->Netlists_ = x.Netlists_;
    this->Symbols_ = x.Symbols_;
    this->Parameters_ = x.Parameters_;
    this->name_ = x.name_;
    this->schematic_id_ = x.schematic_id_;
    this->show_name_ = x.show_name_;
  }

  return *this;
}

Component::
~Component ()
{
}

// Netlists
//

Netlists::
Netlists (const NgspiceNetlist_type& NgspiceNetlist)
: ::xml_schema::type (),
  NgspiceNetlist_ (NgspiceNetlist, this)
{
}

Netlists::
Netlists (::std::unique_ptr< NgspiceNetlist_type > NgspiceNetlist)
: ::xml_schema::type (),
  NgspiceNetlist_ (std::move (NgspiceNetlist), this)
{
}

Netlists::
Netlists (const Netlists& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NgspiceNetlist_ (x.NgspiceNetlist_, f, this)
{
}

Netlists::
Netlists (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NgspiceNetlist_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Netlists::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NgspiceNetlist
    //
    if (n.name () == "NgspiceNetlist" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< NgspiceNetlist_type > r (
        NgspiceNetlist_traits::create (i, f, this));

      if (!NgspiceNetlist_.present ())
      {
        this->NgspiceNetlist_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!NgspiceNetlist_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NgspiceNetlist",
      "");
  }
}

Netlists* Netlists::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Netlists (*this, f, c);
}

Netlists& Netlists::
operator= (const Netlists& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NgspiceNetlist_ = x.NgspiceNetlist_;
  }

  return *this;
}

Netlists::
~Netlists ()
{
}

// Symbols
//

Symbols::
Symbols (const Symbol_type& Symbol)
: ::xml_schema::type (),
  Symbol_ (Symbol, this)
{
}

Symbols::
Symbols (::std::unique_ptr< Symbol_type > Symbol)
: ::xml_schema::type (),
  Symbol_ (std::move (Symbol), this)
{
}

Symbols::
Symbols (const Symbols& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Symbol_ (x.Symbol_, f, this)
{
}

Symbols::
Symbols (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Symbol_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Symbols::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Symbol
    //
    if (n.name () == "Symbol" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Symbol_type > r (
        Symbol_traits::create (i, f, this));

      if (!Symbol_.present ())
      {
        this->Symbol_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Symbol_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Symbol",
      "");
  }
}

Symbols* Symbols::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Symbols (*this, f, c);
}

Symbols& Symbols::
operator= (const Symbols& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Symbol_ = x.Symbol_;
  }

  return *this;
}

Symbols::
~Symbols ()
{
}

// Parameters
//

Parameters::
Parameters ()
: ::xml_schema::type (),
  Parameter_ (this)
{
}

Parameters::
Parameters (const Parameters& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Parameter_ (x.Parameter_, f, this)
{
}

Parameters::
Parameters (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Parameter_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Parameter
    //
    if (n.name () == "Parameter" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Parameter_type > r (
        Parameter_traits::create (i, f, this));

      this->Parameter_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Parameters* Parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Parameters (*this, f, c);
}

Parameters& Parameters::
operator= (const Parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Parameter_ = x.Parameter_;
  }

  return *this;
}

Parameters::
~Parameters ()
{
}

// NgspiceNetlist
//

NgspiceNetlist::
NgspiceNetlist (const value_type& value)
: ::xml_schema::type (),
  value_ (value, this)
{
}

NgspiceNetlist::
NgspiceNetlist (const NgspiceNetlist& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

NgspiceNetlist::
NgspiceNetlist (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void NgspiceNetlist::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }
}

NgspiceNetlist* NgspiceNetlist::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NgspiceNetlist (*this, f, c);
}

NgspiceNetlist& NgspiceNetlist::
operator= (const NgspiceNetlist& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->value_ = x.value_;
  }

  return *this;
}

NgspiceNetlist::
~NgspiceNetlist ()
{
}

// Symbol
//

Symbol::
Symbol (const File_type& File,
        const id_type& id,
        const type_type& type)
: ::xml_schema::type (),
  File_ (File, this),
  id_ (id, this),
  type_ (type, this)
{
}

Symbol::
Symbol (const Symbol& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  File_ (x.File_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

Symbol::
Symbol (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  File_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Symbol::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // File
    //
    if (n.name () == "File" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< File_type > r (
        File_traits::create (i, f, this));

      if (!File_.present ())
      {
        this->File_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!File_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "File",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

Symbol* Symbol::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Symbol (*this, f, c);
}

Symbol& Symbol::
operator= (const Symbol& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->File_ = x.File_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

Symbol::
~Symbol ()
{
}

// Parameter
//

Parameter::
Parameter (const Description_type& Description,
           const name_type& name,
           const unit_type& unit,
           const default_value_type& default_value,
           const show_type& show)
: ::xml_schema::type (),
  Description_ (Description, this),
  name_ (name, this),
  unit_ (unit, this),
  default_value_ (default_value, this),
  show_ (show, this)
{
}

Parameter::
Parameter (const Parameter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Description_ (x.Description_, f, this),
  name_ (x.name_, f, this),
  unit_ (x.unit_, f, this),
  default_value_ (x.default_value_, f, this),
  show_ (x.show_, f, this)
{
}

Parameter::
Parameter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Description_ (this),
  name_ (this),
  unit_ (this),
  default_value_ (this),
  show_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Parameter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Description
    //
    if (n.name () == "Description" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Description_type > r (
        Description_traits::create (i, f, this));

      if (!Description_.present ())
      {
        this->Description_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Description_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Description",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "default_value" && n.namespace_ ().empty ())
    {
      this->default_value_.set (default_value_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "show" && n.namespace_ ().empty ())
    {
      this->show_.set (show_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!unit_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "unit",
      "");
  }

  if (!default_value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "default_value",
      "");
  }

  if (!show_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "show",
      "");
  }
}

Parameter* Parameter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Parameter (*this, f, c);
}

Parameter& Parameter::
operator= (const Parameter& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Description_ = x.Description_;
    this->name_ = x.name_;
    this->unit_ = x.unit_;
    this->default_value_ = x.default_value_;
    this->show_ = x.show_;
  }

  return *this;
}

Parameter::
~Parameter ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Library >
Library_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Library > (
    ::Library_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Library >
Library_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Library > (
    ::Library_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Library >
Library_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Library > (
    ::Library_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Library >
Library_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Library_ (isrc, f, p);
}

::std::unique_ptr< ::Library >
Library_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Library_ (isrc, h, f, p);
}

::std::unique_ptr< ::Library >
Library_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Library_ (isrc, h, f, p);
}

::std::unique_ptr< ::Library >
Library_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Library_ (isrc, f, p);
}

::std::unique_ptr< ::Library >
Library_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Library_ (isrc, h, f, p);
}

::std::unique_ptr< ::Library >
Library_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Library_ (isrc, h, f, p);
}

::std::unique_ptr< ::Library >
Library_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Library > (
    ::Library_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Library >
Library_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Library > (
    ::Library_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Library >
Library_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Library > (
    ::Library_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Library >
Library_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Library > (
      ::Library_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Library" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Library > r (
      ::xsd::cxx::tree::traits< ::Library, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Library",
    "");
}

::std::unique_ptr< ::Library >
Library_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Library" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Library > r (
      ::xsd::cxx::tree::traits< ::Library, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Library",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

